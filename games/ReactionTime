local __Methods,_Classes,tArgs,__EXTENDS={},{},{...},{
	__TERM=term;
	__SHELL=shell;
	__FS=fs;
	__OS=os;
	__PAINTUTILS=paintutils;
}
_Class=function(func, extends)
	local class={print=print;write=write;read=read;__RawClass=func;math=math;table=table;error=error;printError=printError;coroutine=coroutine;pairs=pairs;ipairs=ipairs;tostring=tostring;tonumber=tonumber;}
	function class.__newMethodInstance(mtd)
		if __Methods[mtd] then
			for k,v in pairs(__Methods[mtd].__Classes) do
				_Classes[k]=v
			end
		else
			printError("Failed to load: \""..mtd.."\", method doesn't exist!")
			error()
		end
	end
	function class.__newClassInstance(cls,...)
		if _Classes[cls] then
			local funct=_Classes[cls].__RawClass
			local newClass={print=print;write=write;read=read;__RawClass=funct;math=math;table=table;error=error;printError=printError;coroutine=coroutine;pairs=pairs;ipairs=ipairs;}
			for k,v in pairs(_Classes[cls]) do
				newClass[k]=v
			end
			setfenv(funct, newClass)
			local ok, err = pcall(funct)
			if not ok then printError("Failed to create a class instance!") error() end
			newClass[cls](...)
			return newClass
		else
			printError("Failed to load: \""..cls.."\", class doesn't exist!")
			error()
		end
	end
	if extends then
		if type(extends)=="string" then
			if _Classes[extends] then
				class[extends]={}
				for k,v in pairs(_Classes[extends]) do
					class[extends][k]=v
				end
			end
		else
			printError("Can't extend to a non existing class.")
		end
	end
	if func then
		setfenv(func, class)
		local ok, err = pcall(func)
		if not ok then printError(err) error() end
	end
	return class
end
function _Method(func)
	local method={__Classes={};}
	method._Class=function(func, extends)
		local class={print=print;write=write;read=read;__RawClass=func;math=math;table=table;error=error;printError=printError;coroutine=coroutine;pairs=pairs;ipairs=ipairs;tostring=tostring;tonumber=tonumber;}
		class.__RawClassEnv=getfenv(func)
		function class.__newMethodInstance(mtd)
			if __Methods[mtd] then
				for k,v in pairs(__Methods[mtd].__Classes) do
					method.__Classes[k]=v
				end
			else
				printError("Failed to load: \""..mtd.."\", method doesn't exist!")
				error()
			end
		end
		function class.__newClassInstance(cls,...)
			if method.__Classes[cls] then
				local funct=method.__Classes[cls].__RawClass
				local functEnv=method.__Classes[cls].__RawClassEnv
				local newClass={__RawClassEnv=functEnv;__RawClass=funct;print=print;write=write;read=read;__RawClass=func;}
				for k,v in pairs(method.__Classes[cls]) do
					newClass[k]=v
				end
				setfenv(funct, newClass)
				local ok, err = pcall(funct)
				if not ok then printError("Failed to create a class instance!") error() end
				newClass[cls](...)
				setfenv(funct, functEnv)
				method.__Classes[cls].__RawClass=funct
				return newClass
			else
				printError("Failed to load: \""..cls.."\", class doesn't exist!")
				error()
			end
		end
		if extends then
			if type(extends)=="string" then
				if __EXTENDS[extends] then
					for k,v in pairs(__EXTENDS[extends]) do
						class[k]=v
					end
				elseif method.__Classes[extends] then
					class[extends]={}
					for k,v in pairs(method.__Classes[extends]) do
						class[extends][k]=v
					end
				else
					printError("Can't extend to \""..extends.."\". Class doesn't exist!")
					error()
				end
			else
				printError("Can't extend to a non existing class!")
				error()
			end
		end
		if func then
			setfenv(func, class)
			local ok, err = pcall(func)
			if not ok then printError(err) error() end
		end
		return class
	end
	if func then
		setfenv(func, method)
		local ok, err = pcall(func)
		if not ok then printError(err) error() end
	end
	return method
end

__Methods["CraftOS"]=_Method(function()
	__Classes["Term"]=_Class(function()
		function Term() end
	end,"__TERM")
	__Classes["FileSystem"]=_Class(function()
		function FileSystem() end
	end,"__FS")
	__Classes["PaintUtils"]=_Class(function()
		function PaintUtils() end
	end,"__PAINTUTILS")
	__Classes["Shell"]=_Class(function()
		function Shell() end
	end,"__SHELL")
	__Classes["OS"]=_Class(function()
		function OS() end
	end,"__OS")
end)

--End of: JaC autogenerated code--

__Methods["GUI"] = _Method(function()
__Classes["Label"] = _Class(function()
term=nil;
textColor=nil;
backgroundColor=nil;
x=nil;
y=nil;
label=nil;
function Label(t,name,xx,yy,txtCol,bckCol)
term=t
label=name or "Label"
x=math.floor(xx) or 1
y=math.floor(yy) or 1
textColor=txtCol or 32768
backgroundColor=bckCol or 1
end
function Render()
lastTxtCol=term.getTextColor();
lastBckCol=term.getBackgroundColor();
term.setBackgroundColor(backgroundColor)
term.setTextColor(textColor)
term.setCursorPos(x,y)
term.write(label)
term.setBackgroundColor(lastBckCol)
term.setTextColor(lastTxtCol)
end
end,nil)
__Classes["Button"] = _Class(function()
name=nil;
x=nil;
y=nil;
width=nil;
height=nil;
bckColor=nil;
function Button(t,txt,xx,yy,ww,hh,txtX,txtY,bCol)
term=t
name=txt or "Button"
x=math.floor(xx) or 1
y=math.floor(yy) or 1
width=math.floor(ww) or 8
height=math.floor(hh) or 3
bckColor=bCol or 8
textX=math.floor(txtX) or 2
textY=math.floor(txtY) or 2
end
function AddEventHook(ev)
if(ev[1]=="mouse_click") then
if(ev[2]==1) then
if(ev[3]>=x and ev[3]<=x+width-1 and ev[4]>=y and ev[4]<=y+height-1) then
return true;
else
return false;
end
else
return false;
end
end
end
function Render()
lastTxtCol=term.getTextColor();
lastBckCol=term.getBackgroundColor();
for yy=y,y+height-1 do
for xx=x,x+width-1 do
term.setCursorPos(xx,yy)
term.setBackgroundColor(bckColor)
term.write(" ")
end
end
term.setCursorPos(x+(textX-1),y+(textY-1))
term.write(name)
term.setBackgroundColor(lastBckCol)
term.setTextColor(lastTxtCol)
end
end,nil)
end)

__Methods["Main"] = _Method(function()
__Classes["INI"] = _Class(function()
fs=nil;
function INI(f)
fs=f
end
function retrieve(file)
iniTable={};
line,char,currString,currentSection,currentSectionPos="","","","","";
f=fs.open(file,"r");
sectionStarted,defineSection,foundEqual=false,false,false;
while(true) do
line=f.readLine()
if( not line) then
break
else
line=line.."\n"
end
for i=1,#line do
char=line:sub(i,i)
if(char=="[") then
sectionStarted=true
elseif(char=="]") then
if(sectionStarted) then
iniTable[currString]={}
currentSection=currString
sectionStarted=false
currString=""
else
printError("Cant start section: ["..currString.."]! Usage:")
printError("["..currString.."]")
error()
end
elseif(char=="=") then
currentSectionPos=currString
currString=""
foundEqual=true
elseif(char=="\n") then
if(sectionStarted) then
printError("Cant end section: ["..currString.."]! Usage:")
printError("["..currString.."]")
error()
end
iniTable[currentSection][currentSectionPos]=currString
currString=""
currentSectionPos=""
foundEqual=false
else
if(char==" ") then
if(foundEqual) then
currString=currString..char
end
else
currString=currString..char
end
end
end
end
f.close()
return iniTable;
end

function write(file,data)
f=fs.open(file,"w");
for k,v in pairs(data) do
f.writeLine("["..k.."]")
for _k,_v in pairs(data[k]) do
f.writeLine(tostring(_k).."="..tostring(_v))
end
end
f.close()
end
end,nil)
__Classes["Rectangle"] = _Class(function()
rect=nil;
local function mathBind(val,min,max)
return math.max(math.min(val,max),min);
end
function Rectangle(term,x,y,w,h,color)
x=mathBind(x,1,term.Width-(w-1))
y=mathBind(y,2,term.Height-(h-1))
rect=__newClassInstance("Button",term,"", x, y, w, h, 1, 1, color)
end
function Update(ev)
return rect.AddEventHook(ev);
end
function Render()
rect.Render()
end
end,nil)
__Classes["Game"] = _Class(function()
term=nil;
os=nil;
_TITLE=nil;
madeBy=nil;
poweredBy=nil;
playButton=nil;
upgradeButton=nil;
quitButton=nil;
upgrades=nil;
fs=nil;
backButton=nil;
gameOver=nil;
healthLabel=nil;
maxHealthButton=nil;
maxHealthLabel=nil;
points=0;
pointsLabel=nil;
ini=nil;
colors={0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x100,0x200,0x400,0x800,0x1000,0x2000,0x4000,0x8000};
timerLabel=nil;
restartButton=nil;
GAME={START=1,PAUSE=2,STOP=3};
state=GAME.STOP;
room=1;
rect=nil;
health=3;
maxHealth=3;

local function mathBind(val,min,max)
return math.max(math.min(val,max),min);
end

function Game(t,o,f)
term=t
os=o
fs=f
ini=__newClassInstance("INI",f)
_TITLE=__newClassInstance("Label",term,"Reaction Time!", term.Width/2-6, 1, 0x80, nil)
madeBy=__newClassInstance("Label",term,"Made by: LeDark Lua", term.Width-18, term.Height-1, 0x80, nil)
poweredBy=__newClassInstance("Label",term,"Powered by: JaC", term.Width-18, term.Height, 0x80, nil)
upgrades=__newClassInstance("Label",term,"Upgrades", term.Width/2-3, 1, 0x80, nil)
gameOver=__newClassInstance("Label",term,"Game Over", term.Width/2-4, term.Height/2-2, 0x80, nil)
healthLabel=__newClassInstance("Label",term,"Health: "..health, 1, 1, 0x80, nil)
maxHealthLabel=__newClassInstance("Label",term,"MaxHealth: "..maxHealth, term.Width/2-6, term.Height/2, 0x80, nil)
pointsLabel=__newClassInstance("Label",term,"Points: "..points, 11, 1, 0x80, nil)
playButton=__newClassInstance("Button",term,"Play", term.Width/2-4, term.Height/2-4, 10, 3, 4, 2, 0x20)
restartButton=__newClassInstance("Button",term,"Restart", term.Width/2-4, term.Height/2, 9, 3, 2, 2, 0x20)
upgradeButton=__newClassInstance("Button",term,"Upgrades", term.Width/2-4, term.Height/2, 10, 3, 2, 2, 0x4)
quitButton=__newClassInstance("Button",term,"Quit", term.Width/2-4, term.Height/2+4, 10, 3, 4, 2, 0x4000)
backButton=__newClassInstance("Button",term,"Back", 1, term.Height-2, 10, 3, 4, 2, 0x4000)
maxHealthButton=__newClassInstance("Button",term,"+", term.Width/2+7, term.Height/2-1, 3, 3, 2, 2, 0x4000)
end

function saveGame()
ini.write("settings.ini",{GAME={points=points,maxHp=maxHealth}})
end

function loadGame()
if(fs.exists("settings.ini")) then
content=ini.retrieve("settings.ini");
points=tonumber(content.GAME.points)
maxHealth=tonumber(content.GAME.maxHp)
end
end

function CreateRect()
w=math.random(3,8);
h=math.random(3,8);
color=colors[math.random(#colors)];
rect=__newClassInstance("Rectangle",term,math.random(term.Width),math.random(term.Height),w,h,color)
end
function Reset()
health=maxHealth
CreateRect(w,h)
healthLabel.label="Health: "..health
pointsLabel.label="Points: "..points
end

function Update(event)
if(state~=GAME.STOP) then
if(room==1) then
prPlay=playButton.AddEventHook(event);
prUpgrade=upgradeButton.AddEventHook(event);
prQuit=quitButton.AddEventHook(event);
if(prPlay==true) then
return "PLAY";
elseif(prUpgrade==true) then
return "UPGRADE";
elseif(prQuit==true) then
return "QUIT";
else
return nil;
end
elseif(room==2) then
ok=rect.Update(event);
if(ok) then
rect=nil
term.clear()
points=points+(1)
pointsLabel.label="Points: "..points
CreateRect()
else
if(event[1]=="mouse_click") then
if(event[2]==1) then
rect=nil
term.clear()
health=health-(1)
healthLabel.label="Health: "..health
points=points-(1)
pointsLabel.label="Points: "..points
CreateRect()
end
end
end
if(health<1) then
term.clear()
room=4
end
return nil;
elseif(room==3) then
prBack=backButton.AddEventHook(event);
prHpUp=maxHealthButton.AddEventHook(event);
if(prBack==true) then
return "BACK";
elseif(prHpUp==true) then
if(points>=maxHealth*2) then
points=points-(maxHealth*2)
maxHealth=maxHealth*2
maxHealthLabel.label="MaxHealth: "..maxHealth
end
else
return nil;
end
elseif(room==4) then
prBack=backButton.AddEventHook(event);
prRestart=restartButton.AddEventHook(event);
if(prBack==true) then
return "BACK";
elseif(prRestart==true) then
return "RESTART";
else
return nil;
end
end
end
end

function Draw()
if(state~=GAME.STOP) then
if(room==1) then
_TITLE.Render()
playButton.Render()
upgradeButton.Render()
quitButton.Render()
madeBy.Render()
poweredBy.Render()
elseif(room==2) then
healthLabel.Render()
pointsLabel.Render()
if(rect) then
rect.Render()
end
elseif(room==3) then
upgrades.Render()
backButton.Render()
maxHealthButton.Render()
maxHealthLabel.Render()
elseif(room==4) then
gameOver.Render()
restartButton.Render()
backButton.Render()
end
end
end
end,nil)
__Classes["Main"] = _Class(function()
__newMethodInstance("CraftOS")
__newMethodInstance("GUI")
term=__newClassInstance("Term")
shell=__newClassInstance("Shell")
os=__newClassInstance("OS")
fileSystem=__newClassInstance("FileSystem")
term.Width,term.Height=term.getSize();
game=__newClassInstance("Game",term,os,fileSystem)
function Main()
event=nil;
term.setBackgroundColor(1)
term.clear()
game.loadGame()
game.state=game.GAME.PLAY
while(true) do
event={os.pullEventRaw()}
type=game.Update(event);
if(event[1]=="terminate") then
type="QUIT"
end
if(type=="PLAY") then
term.clear()
game.room=2
game.Reset()
elseif(type=="UPGRADE") then
term.clear()
game.room=3
elseif(type=="BACK") then
term.clear()
if(game.room==3) then
game.room=1
elseif(game.room==4) then
game.room=1
end
elseif(type=="RESTART") then
if(game.room==4) then
term.clear()
game.Reset()
game.room=2
end
elseif(type=="QUIT") then
term.setBackgroundColor(32768)
term.setTextColor(16)
term.setCursorPos(1,1)
term.clear()
print("Thanks for playing!")
game.saveGame()
game.state=game.GAME.STOP
return ;
end
game.Draw()
end
end
end,nil)
end)

--JaC autogenerated code--

if __Methods["Main"] then
	if __Methods["Main"].__Classes["Main"] then
		local cls=__Methods["Main"].__Classes["Main"]
		if cls.Main then
			cls.Main(tArgs)
		end
	end
end
if _Classes.Main then
	if _Classes.Main.Main then
		_Classes.Main.Main(tArgs)
	end
end
